#include <iostream>
#include <vector>
#include <symengine/expression.h>
#include <symengine/derivative.h>
#include <symengine/solve.h>
#include <symengine/symbol.h>
#include <symengine/sets.h>
#include <symengine/parser.h>
using namespace SymEngine;
using namespace std;

int main() {
    RCP<const Symbol> x = symbol("x");
    string user_input;
    Expression poly;

    cout << "Ingrese un polinomio en función de x (ejemplo: 3*x**3 - 4*x**2 + x): ";
    getline(cin, user_input);

    try {
        poly = Expression(parse(user_input));

        Expression first_derivative = diff(poly, x);

        RCP<const Set> solutions = solve(first_derivative.get_basic(), x);

        vector<Expression> critical_points;
        if (is_a<FiniteSet>(*solutions)) {
            const auto &finite_set = down_cast<const FiniteSet &>(*solutions);
            for (const auto &point : finite_set.get_container()) {
                critical_points.push_back(Expression(point));
            }
        }

        cout << "\nPolinomio ingresado: " << poly << endl;
        cout << "Primera derivada: " << first_derivative << endl;
#include <iostream>
#include <vector>
#include <symengine/expression.h>
#include <symengine/derivative.h>
#include <symengine/solve.h>
#include <symengine/symbol.h>
#include <symengine/sets.h>
#include <symengine/parser.h>
using namespace SymEngine;
using namespace std;

int main() {
    // Declarar la variable simbólica
    RCP<const Symbol> x = symbol("x");
    string user_input;
    Expression poly;

    // Solicitar el ingreso del polinomio al usuario
    cout << "Ingrese un polinomio en función de x (ejemplo: 3*x**3 - 4*x**2 + x): ";
    getline(cin, user_input);

    try {
        // Convertir el polinomio ingresado en una expresión simbólica
        poly = Expression(parse(user_input));

        // Calcular la primera derivada
        Expression first_derivative = diff(poly, x);

        // Calcular los puntos críticos resolviendo f'(x) = 0
        RCP<const Set> solutions = solve(first_derivative.get_basic(), x);

        // Convertir soluciones a un vector para facilitar su manejo
        vector<Expression> critical_points;
        if (is_a<FiniteSet>(*solutions)) {
            const auto &finite_set = down_cast<const FiniteSet &>(*solutions);
            for (const auto &point : finite_set.get_container()) {
                critical_points.push_back(Expression(point));
            }
        }

        // Mostrar resultados
        cout << "\nPolinomio ingresado: " << poly << endl;
        cout << "Primera derivada: " << first_derivative << endl;

        // Verificar si se encontraron puntos críticos
        if (critical_points.empty()) {
            cout << "No se encontraron puntos críticos." << endl;
        } else {
            cout << "\nPuntos críticos y su clasificación:" << endl;
            for (const auto &point : critical_points) {
                // Evaluar la derivada a la izquierda y derecha del punto crítico
                auto left_value = first_derivative.subs({{x, point - 1e-3}});  // Ligeramente a la izquierda
                auto right_value = first_derivative.subs({{x, point + 1e-3}}); // Ligeramente a la derecha

                cout << "x = " << point << " -> ";
                // Usamos str() para obtener la cadena
                if (str(left_value).find('-') == string::npos && str(right_value).find('-') != string::npos) {
                    cout << "Máximo local" << endl;
                } else if (str(left_value).find('-') != string::npos && str(right_value).find('-') == string::npos) {
                    cout << "Mínimo local" << endl;
                } else {
                    cout << "Punto de inflexión o sin clasificación" << endl;
                }
            }
        }

    } catch (const SymEngineException &e) {
        cout << "Error al procesar el polinomio: " << e.what() << endl;
    }

    return 0;
}

        if (critical_points.empty()) {
            cout << "No se encontraron puntos críticos." << endl;
        } else {
            cout << "\nPuntos críticos y su clasificación:" << endl;
            for (const auto &point : critical_points) {
                auto left_value = first_derivative.subs({{x, point - 1e-3}});  // Ligeramente a la izquierda
                auto right_value = first_derivative.subs({{x, point + 1e-3}}); // Ligeramente a la derecha

                cout << "x = " << point << " -> ";
                // Usamos str() para obtener la cadena
                if (str(left_value).find('-') == string::npos && str(right_value).find('-') != string::npos) {
                    cout << "Máximo local" << endl;
                } else if (str(left_value).find('-') != string::npos && str(right_value).find('-') == string::npos) {
                    cout << "Mínimo local" << endl;
                } else {
                    cout << "Punto de inflexión o sin clasificación" << endl;
                }
            }
        }

    } catch (const SymEngineException &e) {
        cout << "Error al procesar el polinomio: " << e.what() << endl;
    }

    return 0;
}
